<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orders → Map (Auto-load, Uses Master for Coords)</title>

  <!-- Mapbox GL JS -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script>
    mapboxgl.accessToken = "pk.eyJ1Ijoiam92YW5rOTkiLCJhIjoiY21lOHgzZHIyMGE3eDJrb2Z4azFsemdvcCJ9.Lh3hbX5_F3tGAe_mf0SKFA";
  </script>

  <!-- XLSX for Excel/CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    :root { --bg:#0b0c10; --text:#e8eaed; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #map{width:100%;height:100%;}
    .iw{max-width:300px}
    .iw h3{margin:0 0 6px;font-size:16px}
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // =========================
    // Config: two bundled files
    // =========================
    const MASTER_URL = 'master.csv';   // CSV is fine
    const ORDERS_URL = 'orders.xlsx';  // Orders as xlsx (can be csv too)

    // =========================
    // Helpers
    // =========================
    const pickNum = v => { const n = parseFloat(v); return Number.isFinite(n) ? n : null; };

    async function readSheet(url){
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
      const buf = await res.arrayBuffer();
      const name = url.toLowerCase();

      if (name.endsWith('.csv')) {
        const text = new TextDecoder('utf-8').decode(buf);
        const wb = XLSX.read(text, { type: 'string' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        return XLSX.utils.sheet_to_json(ws, { defval: '' });
      } else {
        const wb = XLSX.read(buf, { type: 'array' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        return XLSX.utils.sheet_to_json(ws, { defval: '' });
      }
    }

    function guessHeaders(headers){
      const H = headers.map(h => String(h||'').toLowerCase());
      const find = (...needles) => headers.find((h,i)=> needles.some(n => H[i].includes(n)) ) || null;
      return {
        name:     find('name','account','store','location'),
        address:  find('address','street'),
        city:     find('city','town'),
        province: find('province','state','prov'),
        postal:   find('postal','zip','postcode'),
        lat:      find('lat','latitude'),
        lng:      headers.find((h,i)=> /long(itude)?|\blng\b/.test(H[i])) || null,
      };
    }

    // Flexible resolver for Master CSV/XLSX header variants
    function resolveMasterCols(headers){
      const H = headers.map(h => String(h||'').toLowerCase());
      const find = (...needles) => headers.find((h,i)=> needles.some(n => H[i].includes(n)));
      return {
        loc:      find('location','store','account','name') || 'Location',
        address:  find('address','street') || 'Address',
        city:     find('city','town') || 'City/Town',
        province: find('province','state','prov') || 'Province',
        postal:   find('postal','postcode','zip') || 'Postal code',
        lat:      find('lat','latitude') || 'Latitude',
        lng:      find('lng','long','longitude') || 'Longitude',
      };
    }

    function escapeHtml(str){
      return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s]));
    }

    // Address normalization
    function canonProvince(s){ s = String(s||'').trim().toLowerCase().replace(/\./g,''); const map = { 'ontario':'on', 'on':'on', 'quebec':'qc', 'qc':'qc', 'british columbia':'bc', 'bc':'bc', 'alberta':'ab', 'ab':'ab' }; return map[s] || s; }
    function canonPostalCA(s){ return String(s||'').toUpperCase().replace(/[^A-Z0-9]/g,''); }
    function canonStreet(s){ let x = String(s||'').toLowerCase().trim();
      x = x.replace(/\b(unit|suite|ste|apt|apartment|#)\s*\w+\b/g,'');
      x = x.replace(/\b(fl|floor)\s*\d+\b/g,'');
      const reps = [[/street\b|st\./g,'st'], [/road\b|rd\./g,'rd'], [/avenue\b|ave\./g,'ave'], [/boulevard\b|blvd\./g,'blvd'], [/drive\b|dr\./g,'dr'], [/court\b|ct\./g,'ct'], [/crescent\b|cres\./g,'cres'], [/trail\b|trl\./g,'trl'], [/highway\b|hwy\./g,'hwy'], [/place\b|pl\./g,'pl'], [/terrace\b|terr\./g,'terr']];
      reps.forEach(([re,to])=> x = x.replace(re,to));
      x = x.replace(/[.,]/g,' ');
      x = x.replace(/\s+/g,' ').trim();
      return x;
    }
    function keyFull(addr, city, prov, postal){ return [canonStreet(addr), String(city||'').toLowerCase().trim(), canonProvince(prov), canonPostalCA(postal)].filter(Boolean).join('|'); }
    function keyAddrPostal(addr, postal){ return [canonStreet(addr), canonPostalCA(postal)].filter(Boolean).join('|'); }
    function keyAddrCityProv(addr, city, prov){ return [canonStreet(addr), String(city||'').toLowerCase().trim(), canonProvince(prov)].filter(Boolean).join('|'); }
    function keyPostal(postal){ return canonPostalCA(postal); }

    // Master indices
    const MULTI = Symbol('multi');
    const masterIdx = { full:new Map(), addrPostal:new Map(), addrCityProv:new Map(), postal:new Map() };
    function setUnique(map, key, entry){ if (!key) return; const ex = map.get(key); if (!ex) map.set(key, entry); else if (ex !== entry) map.set(key, MULTI); }

    function ingestMasterRows(rows){
      masterIdx.full.clear(); masterIdx.addrPostal.clear(); masterIdx.addrCityProv.clear(); masterIdx.postal.clear();
      if (!rows.length) return;
      const headers = Object.keys(rows[0]);
      const C = resolveMasterCols(headers);

      for (const r of rows){
        const name    = String(r[C.loc] ?? '').trim();
        const address = String(r[C.address] ?? '').trim();
        const city    = String(r[C.city] ?? '').trim();
        const postal  = String(r[C.postal] ?? '').trim();
        const lat     = pickNum(r[C.lat]);
        const lng     = pickNum(r[C.lng]);
        if (!address) continue;
        // If your Master has province column use it; else default
        const province = String(r[C.province] ?? 'ON').trim() || 'ON';

        const entry = { name: name || address, address, city, province, postal, lat, lng };
        const kFull = keyFull(address, city, province, postal);
        const kAP   = keyAddrPostal(address, postal);
        const kACP  = keyAddrCityProv(address, city, province);
        const kP    = keyPostal(postal);
        setUnique(masterIdx.full, kFull, entry);
        setUnique(masterIdx.addrPostal, kAP, entry);
        setUnique(masterIdx.addrCityProv, kACP, entry);
        setUnique(masterIdx.postal, kP, entry);
      }
    }

    function findMaster(address, city, province, postal){
      const k1 = keyFull(address, city, province, postal);
      const k2 = keyAddrPostal(address, postal);
      const k3 = keyAddrCityProv(address, city, province);
      const k4 = keyPostal(postal);
      if (masterIdx.full.has(k1)) { const v = masterIdx.full.get(k1); if (v !== MULTI) return v; }
      if (masterIdx.addrPostal.has(k2)) { const v = masterIdx.addrPostal.get(k2); if (v !== MULTI) return v; }
      if (masterIdx.addrCityProv.has(k3)) { const v = masterIdx.addrCityProv.get(k3); if (v !== MULTI) return v; }
      if (masterIdx.postal.has(k4)) { const v = masterIdx.postal.get(k4); if (v !== MULTI) return v; }
      return null;
    }

    // =========================
    // Map init (pins only from Orders, enriched by Master)
    // =========================
    const MB_SOURCE = 'orders-pins';
    let map;

    async function init(){
      // Map
      map = new mapboxgl.Map({ container:'map', style:'mapbox://styles/mapbox/streets-v12', center:[-79.4,43.7], zoom:8 });
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');
      await new Promise(res => map.on('load', res));

      // Load files (now using readSheet for both)
      const [masterRows, orderRows] = await Promise.all([
        readSheet(MASTER_URL),
        readSheet(ORDERS_URL)
      ]);
      ingestMasterRows(masterRows);

      if (!orderRows.length) return;
      const headers = Object.keys(orderRows[0]);
      const cols = guessHeaders(headers);

      const feats = [];
      const bounds = new mapboxgl.LngLatBounds();
      let hasBounds = false;

      for (const r of orderRows){
        let lat = pickNum(r[cols.lat]);
        let lng = pickNum(r[cols.lng]);

        let address  = String(r[cols.address]||'').trim();
        let city     = String(r[cols.city]||'').trim();
        let province = String(r[cols.province]||'').trim();
        let postal   = String(r[cols.postal]||'').trim();

        // Fill from Master if missing lat/lng (and optionally address parts)
        if (lat==null || lng==null){
          const m = findMaster(address, city, province, postal);
          if (m){
            if (lat==null && Number.isFinite(m.lat)) lat = m.lat;
            if (lng==null && Number.isFinite(m.lng)) lng = m.lng;
            if (!address && m.address) address = m.address;
            if (!city && m.city) city = m.city;
            if (!province && m.province) province = m.province;
            if (!postal && m.postal) postal = m.postal;
          }
        }

        if (lat==null || lng==null) continue; // still no coords → skip

        const name = String(r[cols.name]||'').trim();
        feats.push({ type:'Feature', geometry:{ type:'Point', coordinates:[lng,lat] }, properties:{ name, address, city, province, postal } });
        bounds.extend([lng,lat]); hasBounds = true;
      }

      const fc = { type:'FeatureCollection', features: feats };
      map.addSource(MB_SOURCE, { type:'geojson', data: fc });

      map.addLayer({ id:'orders-points', type:'circle', source:MB_SOURCE, paint:{ 'circle-color':'#4fc3f7', 'circle-radius':6, 'circle-stroke-width':1, 'circle-stroke-color':'#0b0e14' } });

      map.on('click', 'orders-points', (e) => {
        const p = e.features[0].properties;
        const addr = [p.address, p.city, p.province, p.postal].filter(Boolean).join(', ');
        const html = `
          <div class="iw">
            <h3>${escapeHtml(p.name || addr || 'Location')}</h3>
            ${addr ? `<div>${escapeHtml(addr)}</div>` : ''}
          </div>`;
        new mapboxgl.Popup({ offset: 12 })
          .setLngLat(e.features[0].geometry.coordinates)
          .setHTML(html)
          .addTo(map);
      });

      map.on('mouseenter', 'orders-points', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'orders-points', () => map.getCanvas().style.cursor = '');

      if (hasBounds) { try { map.fitBounds(bounds, { padding: 40, duration: 0 }); } catch {} }
    }

    // Auto-run
    init().catch(err => {
      console.error(err);
      alert('Failed to load master.csv and/or orders.xlsx. Ensure both are next to this HTML (not via file://).');
    });
  </script>
</body>
</html>
